---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by arciesis.
--- DateTime: 2/22/24 5:19 PM
---

--- @module PalDpsMeter.partyTeam
local partyTeam = {}

local constants = {
   MIN_PER_TEAM = 1,
   MAX_PER_TEAM = 5,
}
---@class PartyTeam represent the team of otomo of the player
---@field private members table a table that contains all of the otomo in the team of the player
---@field private currentlyOutOtomo number the out otomo slot index or -1 if none
---@field private nbOtomoCurrentlyInTeam number The number of otomo currently in the team
local PartyTeam = {}

--- Getter of the field members
--- @return table the team of otomo
function PartyTeam:getMembers()
   return self.members
end

----- Get the actual Numbers of otomos in the team since the first otomo can be empty
----- @return number actualNbMembers the actual number of otomo in the team
-----@private
--function PartyTeam:getActualNbMembers()
--   local actualNbMembers = constants.MAX_PER_TEAM
--   local members = self:getMembers()
--   for i = 1, constants.MAX_PER_TEAM do
--      if not members[i] then
--         actualNbMembers = actualNbMembers - 1
--      end
--   end
--   return actualNbMembers
--end

--- @return number slotID of the currently out otomo
function PartyTeam:getCurrentlyOutOtomo()
   return self.currentlyOutOtomo
end

---@return number @nbOtomoCurrentlyInTeam
function PartyTeam:getNbOtomoCurrentlyInTeam()
   return self.nbOtomoCurrentlyInTeam
end

---@param otomos table the @Otomo to set in the team
function PartyTeam:setMembers(otomos)
   self.members = otomos
end

---@param slotIndex number
function PartyTeam:setCurrentlyOutOtomo(slotIndex)
   print(string.format("slotID: %i", slotIndex))
   if slotIndex < constants.MIN_PER_TEAM or slotIndex > constants.MAX_PER_TEAM then
      print("[PalDpsMeter] Your are trying to set a slot out of band")
      return
   end
   self.currentlyOutOtomo = slotIndex
end

---@param nb number
function PartyTeam:setNbOtomoCurrentlyInTeam(nb)
   if nb < constants.MIN_PER_TEAM and nb > constants.MAX_PER_TEAM then
      print("[PalDpsMeter] try to set more otomo than you can have in your team")
      return
   end
   self.nbOtomoCurrentlyInTeam = nb
end

--- Add an Otomo via its slotID replacing the previous one
---@param otomo Otomo the new otomo to place in the team
function PartyTeam:addOtomo(otomo)
   local otomoSlotID = otomo:getSlotInParty()
   local team = self:getMembers()
   team[otomoSlotID] = otomo

   -- table.insert(self:getTeam(), otomoSlotID, otomo)

   if self:getNbOtomoCurrentlyInTeam() == nil or self:getNbOtomoCurrentlyInTeam() == 0 then
      self:setNbOtomoCurrentlyInTeam(1)
   end

   self:setNbOtomoCurrentlyInTeam(self:getNbOtomoCurrentlyInTeam() + 1)
end

--- @param slotID number
function PartyTeam:removeOtomoBySlotID(slotID)
   table.remove(self:getMembers(), slotID)
   self._nbOtomoCurrentlyInTeam = self._nbOtomoCurrentlyInTeam - 1
end

---@param otomo Otomo
function PartyTeam:updateOtomoByOtomo(otomo)
   local otomoSlotID = otomo:getSlotInParty()
   self:getMembers()[otomoSlotID] = otomo
end

---@param otomo Otomo
function PartyTeam:removeOtomo(otomo)
   local otomoSlotID = otomo:getSlotInParty()
   self:removeOtomoBySlotID(otomoSlotID)
end

--- @param slotIndex number the index of the otomo to retrieve
--- @return Otomo otomo at the index or nil if none was found
--- @public
function PartyTeam:getOtomoBySlotID(slotIndex)
   if slotIndex < constants.MIN_PER_TEAM or slotIndex > constants.MAX_PER_TEAM then
      error("indexing a wrong slotID")
   end

   local currentTeam = self:getMembers()

   if not currentTeam then
      error("team is empty")
   end

   if not currentTeam[slotIndex] then
      error("No otomo found at this index")
   end

   return currentTeam[slotIndex]
end

---Update the otomo who is out
---@param newSlotIndex number the new @slotID
function PartyTeam:updateCurrentlyOutOtomo(newSlotIndex)
   if newSlotId < constants.MIN_PER_TEAM or newSlotIndex > constants.MAX_PER_TEAM then
      error("[PalDpsMeter] Your are trying to update the outOtomo with a wrong Index")
   end

   self:setCurrentlyOutOtomo(newSlotIndex)
end

----- Since in the game the empty slot are replaced by non empty otomo we need to remove them from
-----(Recursive version)
----- @param otomos table the table representing the otomos
----- @param lastOtomo Otomo|nil the last Otomo handled
----- @param index number the index to handle
----- @return table the Otomos without duplicate
----- @private
--function partyTeam.removeDuplicateRecursive(otomos, lastOtomo, index)
--   if index > constants.MAX_PER_TEAM then
--      return otomos
--   end
--
--   if not otomos[index] then
--      return otomos
--   end
--
--   if not lastOtomo and (index == 1) then
--      lastOtomo = otomos[index]
--      return partyTeam.removeDuplicateRecursive(otomos, lastOtomo, index + 1)
--   end
--
--   if otomos[index]:isSame(lastOtomo) then
--      table.remove(otomos, index)
--      return partyTeam.removeDuplicateRecursive(otomos, lastOtomo, index)
--   end
--
--   return partyTeam.removeDuplicateRecursive(otomos, lastOtomo, index + 1)
--end

----- Since in the game the empty slot are replaced by non empty otomo we need to remove them from
----- the party manually thus this function
----- @param team PartyTeam a new team on which we need to check if there is duplicate
----- @public
--function partyTeam.removeDuplicate(team)
--   for _, value in ipairs(team) do
--      print(type(value))
--   end
--   local otomos = team:getMembers()
--   local newTeam = partyTeam.removeDuplicate(otomos, nil, 1)
--   team:updateTeam(newTeam)
--   -- TODO: create the last method when everything is working correctly
--end
--- private method tostring
--- @return string|nil the string to print
--- @private
function PartyTeam:__tostring()
   local str = ""
   str = string.format(
         "nbOtomoInTeam: %d, currentlyOutOtomo: %d\n",
         self:getNbOtomoCurrentlyInTeam(),
         self:getCurrentlyOutOtomo()
   )
   --- @type Otomo
   local otomo
   for i = 1, self:getNbOtomoCurrentlyInTeam() do
      otomo = nil
      
      if self:getMembers()[i] then
         otomo = self:getOtomoBySlotID(i)
         str = str .. string.format("TeamMember: [%s]\n", otomo:ToString())
      end
   end
   return str
end

---@return string|nil str @PartyTeam object as string
function PartyTeam:ToString()
   return self:__tostring()
end

-- function PartyTeam:__index(key)
--     if string.sub(key, 1, 1) == "_" then
--         error("Attempting to access private member:")
--     end
-- end

--- Get the modified otomos between the actual Members (old/self) and the newTeam
--- @param newPartyTeam PartyTeam the new set of members
--- @return table the set of otomos to insert into the actual team
function PartyTeam:getModifiedOtomos(newPartyTeam)
   local modifiedOtomos = {}
   local oldPartyTeamMembers = self:getMembers()
   local newPartyTeamMembers = newPartyTeam:getMembers()

   -- iterate over each combination of otomos to find which one has been modified
   -- iterate each time by 1 to 5 because we can have only 1 otomo in the team in the last slot
   for newIndex = constants.MIN_PER_TEAM, constants.MAX_PER_TEAM, 1 do
      for oldIndex = constants.MIN_PER_TEAM, constants.MAX_PER_TEAM, 1 do
         if not newPartyTeamMembers[newIndex] then
            break
         end

         if not oldPartyTeamMembers[oldIndex] then
            break
         end

         if not newPartyTeamMembers[newIndex].isEqual(oldPartyTeamMembers[oldIndex]) then
            table.insert(modifiedOtomos, newPartyTeamMembers[newIndex])
            break
         end
      end
   end
   return modifiedOtomos
end

--- get an update on the otomos that has been swapped off the team
--- @param newPartyTeam PartyTeam the complete set of the new team
--- @return table swappedOtomos A table containing the newly added otomos
--- @public
function PartyTeam:getNotModifiedOtomos(newPartyTeam)
   local swappedOtomos = {}
   local oldPartyTeamMembers = self:getMembers()
   local newPartyTeamMembers = newPartyTeam:getMembers()

   -- iterate over each combination of otomos to find which one has not been swapped
   for _, newOtomo in ipairs(newPartyTeamMembers) do
      for _, oldOtomo in ipairs(oldPartyTeamMembers) do
         if newOtomo.isEqual(oldOtomo) then
            table.insert(swappedOtomos, newOtomo)
            break
         end
      end
   end
   return swappedOtomos
end

--- @param otomos table The otomos in the team, can be 1 to 5 if its 0 then the team team is empty
function partyTeam.new(otomos)
   local self = {}
   setmetatable(self, { __index = PartyTeam })

   self.members = otomos
   -- TODO: Need to be notify
   self.currentlyOutOtomo = -1
   self.nbOtomoCurrentlyInTeam = #otomos

   return self
end

return partyTeam